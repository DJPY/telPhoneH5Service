#!/usr/bin/env
#coding=utf-8

#国内提高下载速度
#pip install -i https://pypi.tuna.tsinghua.edu.cn/simple 库

from fastapi import FastAPI, HTTPException, Depends, Header, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from typing import Union, Optional, Dict, Any
from pydantic import BaseModel, validator, validator
import hashlib
import re

# 导入配置和工具
from config import config
from DjSpider.DBcrud import Mysql_crud, Redis_crud
from contactFuc import contact
import jwt
import datetime
import time
import re
import logging

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# 启动
# uvicorn ContactH5.main:app --reload  
# uvicorn ContactH5.main:app --host 0.0.0.0 --port 8080 --reload

# 数据库连接
mysql = Mysql_crud(
    host=config.DB_CONFIG['host'],
    port=config.DB_CONFIG['port'],
    user=config.DB_CONFIG['user'],
    passwd=config.DB_CONFIG['password'],
    db=config.DB_CONFIG['database'],
    charset=config.DB_CONFIG['charset']
)

redis = Redis_crud(
    host=config.REDIS_CONFIG['host'],
    port=config.REDIS_CONFIG['port'],
    db=config.REDIS_CONFIG['db'],
    password=config.REDIS_CONFIG['password']
)

contact = contact()

class ContactItem(BaseModel):
    id:int
    index:str
    name:str
    tel:str
    age:Union[int,str,None]=None
    sex:str
    address:str
    
    @validator('tel')
    def validate_tel(cls, v):
        if not re.match(r'^1[3-9]\d{9}

class ContactParams(BaseModel):
    id:Union[int,None]=None

class User(BaseModel):
    user:str
    passwd:str

class Code(BaseModel):
    email:str
    
    @validator('email')
    def validate_email(cls, v):
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

class Sign(BaseModel):
    user:str
    passwd:str
    email:str
    code:Union[str,None]=None
    
    @validator('user')
    def validate_user(cls, v):
        if not re.match(r'^[a-zA-Z0-9_]{3,20}

# JWT认证相关函数
import hashlib

def hash_password(password: str) -> str:
    """密码加密"""
    return hashlib.sha256(password.encode('utf-8')).hexdigest()

def encode_auth_token(user_id: int, username: str) -> str:
    """生成JWT Token"""
    try:
        payload = {
            'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
            'iat': datetime.datetime.utcnow(),
            'sub': user_id,
            'username': username
        }
        return jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGORITHM)
    except Exception as e:
        raise HTTPException(status_code=500, detail="Token生成失败")

def decode_auth_token(auth_token: str) -> dict:
    """验证JWT Token"""
    try:
        payload = jwt.decode(auth_token, SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效的Token")

async def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """验证Token依赖函数"""
    if not authorization:
        raise HTTPException(status_code=401, detail="未提供认证信息")
    
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证方案无效")
        
        payload = decode_auth_token(token)
        
        # 验证用户是否仍然存在
        sql = "SELECT * FROM user WHERE id = %s AND username = %s"
        users = mysql.mysql_output_data(sql, (payload['sub'], payload['username']))
        if not users:
            raise HTTPException(status_code=401, detail="用户不存在或已被删除")
        
        return {"user": users[0], "payload": payload}
    except ValueError:
        raise HTTPException(status_code=401, detail="认证信息格式错误")

app = FastAPI(
    title="电话H5服务",
    description="联系人管理系统API",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 全局异常处理
@app.exception_handler(HTTPException)
async def http_exception_handler(request, exc):
    return JSONResponse(
        status_code=exc.status_code,
        content={"code": exc.status_code, "message": exc.detail, "data": None}
    )

@app.exception_handler(Exception)
async def general_exception_handler(request, exc):
    return JSONResponse(
        status_code=500,
        content={"code": 500, "message": "服务器内部错误", "data": None}
    )

@app.get('/')
async def home():
    return {'message':"home"}

@app.post('/h5/contact/code')
async def contactCode(item:Code):
    item_dict = item.dict()
    print("item_dict:",item_dict)
    code = contact.getCode()
    content="验证码为：%s" % code
    print("content:",content)
    redis.r_set(item_dict['email'], code)
    # contact.postMail(item_dict['email'], content)
    return {"success":True}

#sign
@app.post('/h5/contact/sign')
async def contactLogin(item:Sign):
    item_dict=item.dict()
    print("item:",item_dict)
    # return {"success":True}
    return item_dict

#login
@app.post('/h5/contact/login')
async def contactLogin(item:User):
    item_dict = item.dict()
    username = item_dict['user']
    password = item_dict['passwd']
    
    print("登录请求:", username)
    
    try:
        # 查询用户信息
        sql = "SELECT * FROM user WHERE username = %s"
        users = mysql.mysql_output_data(sql, (username,))
        
        if not users:
            return {"success": False, "message": "用户不存在"}
        
        user = users[0]  # 获取第一个用户
        
        # 验证密码（使用加密验证）
        hashed_password = hash_password(password)
        if user.get('password') == hashed_password:
            # 更新登录时间
            login_time = int(time.time())
            update_sql = "UPDATE user SET login_time = %s WHERE username = %s"
            mysql.mysql_update_data('user', {'login_time': login_time}, 'username', username)
            
            # 生成Token
            token = encode_auth_token(user['id'], user['username'])
            
            return {
                "success": True,
                "message": "登录成功",
                "token": token,
                "user_id": user['id'],
                "username": user['username']
            }
        else:
            return {"success": False, "message": "密码错误"}
            
    except Exception as e:
        print(f"登录错误: {str(e)}")
        return {"success": False, "message": f"登录失败: {str(e)}"}

#联系人列表
@app.post('/h5/contact/list')
async def contactList(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求联系人列表")
    
    sql = "SELECT * FROM list ORDER BY `initial`"
    data = mysql.mysql_output_data(sql)  
    return {
        "data": data,
        "success": True,
        "user_id": user_info['user']['id']
    }


#联系人详情
@app.post('/h5/contact/info')
async def contactInfo(item:ContactParams, user_info: dict = Depends(verify_token)):
    item_dict = item.dict()
    print(f"用户 {user_info['user']['username']} 请求联系人详情: {item}")
    
    if item_dict.get('id'):
        sql = "SELECT * FROM list WHERE id = %s"
        data = mysql.mysql_output_data(sql, (item_dict['id'],))
        if data:
            return {
                "data": data[0],
                "success": True,
                "user_id": user_info['user']['id']
            }
        else:
            return {"success": False, "message": "联系人不存在"}
    else:
        return {"success": False, "message": "缺少联系人ID"}

# 用户信息接口
@app.get('/h5/contact/userinfo')
async def getUserInfo(user_info: dict = Depends(verify_token)):
    """获取当前登录用户信息"""
    user = user_info['user']
    return {
        "success": True,
        "data": {
            "user_id": user['id'],
            "username": user['username'],
            "email": user.get('email', ''),
            "login_time": user.get('login_time', '')
        }
    }

# Token验证接口
@app.post('/h5/contact/verify')
async def verifyToken(user_info: dict = Depends(verify_token)):
    """验证Token有效性"""
    return {
        "success": True,
        "message": "Token有效",
        "user_id": user_info['user']['id'],
        "exp": user_info['payload'].get('exp')
    }

#baidu OCR
@app.post('/h5/contact/ocr')
async def contactOCR(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求OCR功能")
    
    url = "https://aip.baidubce.com/oauth/2.0/token?client_id=&client_secret=&grant_type=client_credentials"
    payload = ""
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    return {
        "success": True,
        "message": "OCR功能调用成功",
        "user_id": user_info['user']['id']
    }
, v):
            raise ValueError('用户名必须是3-20位的字母、数字或下划线')
        return v
    
    @validator('passwd')
    def validate_passwd(cls, v):
        if len(v) < 6:
            raise ValueError('密码长度不能少于6位')
        return v
    
    @validator('email')
    def validate_email(cls, v):
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

# JWT认证相关函数
def encode_auth_token(user_id: int) -> str:
    """
    生成认证Token
    :param user_id: 用户ID
    :return: JWT Token字符串
    """
    try:
        payload = {
            "user_id": user_id,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
            "iat": datetime.datetime.utcnow(),
            "iss": "telphone-h5-service"
        }
        
        token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGORITHM)
        return token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Token生成失败: {str(e)}")

def decode_auth_token(token: str) -> dict:
    """
    验证Token
    :param token: JWT Token
    :return: 解码后的payload
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效Token")

async def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """
    验证Token依赖函数
    :param authorization: Authorization头
    :return: 用户信息
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="未提供认证Token")
    
    # 提取Bearer Token
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证方案无效")
    except ValueError:
        raise HTTPException(status_code=401, detail="Token格式无效")
    
    # 解码Token
    payload = decode_auth_token(token)
    
    # 验证用户是否存在
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Token无效")
    
    sql = "SELECT * FROM user WHERE id = %s"
    users = mysql.mysql_output_data(sql, (user_id,))
    
    if not users:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    return {"user": users[0], "payload": payload}

app=FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,  # 改为True以支持认证
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get('/')
async def home():
    return {'message':"home"}

@app.post('/h5/contact/code')
async def contactCode(item:Code):
    item_dict = item.dict()
    print("item_dict:",item_dict)
    code = contact.getCode()
    content="验证码为：%s" % code
    print("content:",content)
    redis.r_set(item_dict['email'], code)
    # contact.postMail(item_dict['email'], content)
    return {"success":True}

#sign
@app.post('/h5/contact/sign')
async def contactLogin(item:Sign):
    item_dict=item.dict()
    print("item:",item_dict)
    # return {"success":True}
    return item_dict

#login
@app.post('/h5/contact/login')
async def contactLogin(item:User):
    item_dict = item.dict()
    username = item_dict['user']
    password = item_dict['passwd']
    
    print("登录请求:", username)
    
    try:
        # 查询用户信息
        sql = "SELECT * FROM user WHERE username = %s"
        users = mysql.mysql_output_data(sql, (username,))
        
        if not users:
            return {"success": False, "message": "用户不存在"}
        
        user = users[0]  # 获取第一个用户
        
        # 验证密码
        if user.get('password') == password:
            # 更新登录时间
            login_time = int(time.time())
            update_sql = "UPDATE user SET login_time = %s WHERE username = %s"
            mysql.mysql_update_data('user', {'login_time': login_time}, 'username', username)
            
            # 生成Token
            token = encode_auth_token(user['id'])
            
            return {
                "success": True,
                "message": "登录成功",
                "token": token,
                "user_id": user['id'],
                "username": user['username']
            }
        else:
            return {"success": False, "message": "密码错误"}
            
    except Exception as e:
        print(f"登录错误: {str(e)}")
        return {"success": False, "message": f"登录失败: {str(e)}"}

#联系人列表
@app.post('/h5/contact/list')
async def contactList(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求联系人列表")
    
    sql = "SELECT * FROM list ORDER BY `initial`"
    data = mysql.mysql_output_data(sql)  
    return {
        "data": data,
        "success": True,
        "user_id": user_info['user']['id']
    }


#联系人详情
@app.post('/h5/contact/info')
async def contactInfo(item:ContactParams, user_info: dict = Depends(verify_token)):
    item_dict = item.dict()
    print(f"用户 {user_info['user']['username']} 请求联系人详情: {item}")
    
    if item_dict.get('id'):
        sql = "SELECT * FROM list WHERE id = %s"
        data = mysql.mysql_output_data(sql, (item_dict['id'],))
        if data:
            return {
                "data": data[0],
                "success": True,
                "user_id": user_info['user']['id']
            }
        else:
            return {"success": False, "message": "联系人不存在"}
    else:
        return {"success": False, "message": "缺少联系人ID"}

# 用户信息接口
@app.get('/h5/contact/userinfo')
async def getUserInfo(user_info: dict = Depends(verify_token)):
    """获取当前登录用户信息"""
    user = user_info['user']
    return {
        "success": True,
        "data": {
            "user_id": user['id'],
            "username": user['username'],
            "email": user.get('email', ''),
            "login_time": user.get('login_time', '')
        }
    }

# Token验证接口
@app.post('/h5/contact/verify')
async def verifyToken(user_info: dict = Depends(verify_token)):
    """验证Token有效性"""
    return {
        "success": True,
        "message": "Token有效",
        "user_id": user_info['user']['id'],
        "exp": user_info['payload'].get('exp')
    }

#baidu OCR
@app.post('/h5/contact/ocr')
async def contactOCR(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求OCR功能")
    
    url = "https://aip.baidubce.com/oauth/2.0/token?client_id=&client_secret=&grant_type=client_credentials"
    payload = ""
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    return {
        "success": True,
        "message": "OCR功能调用成功",
        "user_id": user_info['user']['id']
    }
, v):
            raise ValueError('邮箱格式不正确')
        return v

# JWT认证相关函数
def encode_auth_token(user_id: int) -> str:
    """
    生成认证Token
    :param user_id: 用户ID
    :return: JWT Token字符串
    """
    try:
        payload = {
            "user_id": user_id,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
            "iat": datetime.datetime.utcnow(),
            "iss": "telphone-h5-service"
        }
        
        token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGORITHM)
        return token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Token生成失败: {str(e)}")

def decode_auth_token(token: str) -> dict:
    """
    验证Token
    :param token: JWT Token
    :return: 解码后的payload
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效Token")

async def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """
    验证Token依赖函数
    :param authorization: Authorization头
    :return: 用户信息
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="未提供认证Token")
    
    # 提取Bearer Token
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证方案无效")
    except ValueError:
        raise HTTPException(status_code=401, detail="Token格式无效")
    
    # 解码Token
    payload = decode_auth_token(token)
    
    # 验证用户是否存在
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Token无效")
    
    sql = "SELECT * FROM user WHERE id = %s"
    users = mysql.mysql_output_data(sql, (user_id,))
    
    if not users:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    return {"user": users[0], "payload": payload}

app=FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,  # 改为True以支持认证
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get('/')
async def home():
    return {'message':"home"}

@app.post('/h5/contact/code')
async def contactCode(item:Code):
    item_dict = item.dict()
    print("item_dict:",item_dict)
    code = contact.getCode()
    content="验证码为：%s" % code
    print("content:",content)
    redis.r_set(item_dict['email'], code)
    # contact.postMail(item_dict['email'], content)
    return {"success":True}

#sign
@app.post('/h5/contact/sign')
async def contactLogin(item:Sign):
    item_dict=item.dict()
    print("item:",item_dict)
    # return {"success":True}
    return item_dict

#login
@app.post('/h5/contact/login')
async def contactLogin(item:User):
    item_dict = item.dict()
    username = item_dict['user']
    password = item_dict['passwd']
    
    print("登录请求:", username)
    
    try:
        # 查询用户信息
        sql = "SELECT * FROM user WHERE username = %s"
        users = mysql.mysql_output_data(sql, (username,))
        
        if not users:
            return {"success": False, "message": "用户不存在"}
        
        user = users[0]  # 获取第一个用户
        
        # 验证密码
        if user.get('password') == password:
            # 更新登录时间
            login_time = int(time.time())
            update_sql = "UPDATE user SET login_time = %s WHERE username = %s"
            mysql.mysql_update_data('user', {'login_time': login_time}, 'username', username)
            
            # 生成Token
            token = encode_auth_token(user['id'])
            
            return {
                "success": True,
                "message": "登录成功",
                "token": token,
                "user_id": user['id'],
                "username": user['username']
            }
        else:
            return {"success": False, "message": "密码错误"}
            
    except Exception as e:
        print(f"登录错误: {str(e)}")
        return {"success": False, "message": f"登录失败: {str(e)}"}

#联系人列表
@app.post('/h5/contact/list')
async def contactList(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求联系人列表")
    
    sql = "SELECT * FROM list ORDER BY `initial`"
    data = mysql.mysql_output_data(sql)  
    return {
        "data": data,
        "success": True,
        "user_id": user_info['user']['id']
    }


#联系人详情
@app.post('/h5/contact/info')
async def contactInfo(item:ContactParams, user_info: dict = Depends(verify_token)):
    item_dict = item.dict()
    print(f"用户 {user_info['user']['username']} 请求联系人详情: {item}")
    
    if item_dict.get('id'):
        sql = "SELECT * FROM list WHERE id = %s"
        data = mysql.mysql_output_data(sql, (item_dict['id'],))
        if data:
            return {
                "data": data[0],
                "success": True,
                "user_id": user_info['user']['id']
            }
        else:
            return {"success": False, "message": "联系人不存在"}
    else:
        return {"success": False, "message": "缺少联系人ID"}

# 用户信息接口
@app.get('/h5/contact/userinfo')
async def getUserInfo(user_info: dict = Depends(verify_token)):
    """获取当前登录用户信息"""
    user = user_info['user']
    return {
        "success": True,
        "data": {
            "user_id": user['id'],
            "username": user['username'],
            "email": user.get('email', ''),
            "login_time": user.get('login_time', '')
        }
    }

# Token验证接口
@app.post('/h5/contact/verify')
async def verifyToken(user_info: dict = Depends(verify_token)):
    """验证Token有效性"""
    return {
        "success": True,
        "message": "Token有效",
        "user_id": user_info['user']['id'],
        "exp": user_info['payload'].get('exp')
    }

#baidu OCR
@app.post('/h5/contact/ocr')
async def contactOCR(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求OCR功能")
    
    url = "https://aip.baidubce.com/oauth/2.0/token?client_id=&client_secret=&grant_type=client_credentials"
    payload = ""
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    return {
        "success": True,
        "message": "OCR功能调用成功",
        "user_id": user_info['user']['id']
    }
, v):
            raise ValueError('手机号格式不正确')
        return v

class ContactParams(BaseModel):
    id:Union[int,None]=None

class User(BaseModel):
    user:str
    passwd:str

class Code(BaseModel):
    email:str

class Sign(BaseModel):
    user:str
    passwd:str
    email:str
    code:Union[str,None]=None
    
    @validator('user')
    def validate_user(cls, v):
        if not re.match(r'^[a-zA-Z0-9_]{3,20}

# JWT认证相关函数
def encode_auth_token(user_id: int) -> str:
    """
    生成认证Token
    :param user_id: 用户ID
    :return: JWT Token字符串
    """
    try:
        payload = {
            "user_id": user_id,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
            "iat": datetime.datetime.utcnow(),
            "iss": "telphone-h5-service"
        }
        
        token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGORITHM)
        return token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Token生成失败: {str(e)}")

def decode_auth_token(token: str) -> dict:
    """
    验证Token
    :param token: JWT Token
    :return: 解码后的payload
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效Token")

async def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """
    验证Token依赖函数
    :param authorization: Authorization头
    :return: 用户信息
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="未提供认证Token")
    
    # 提取Bearer Token
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证方案无效")
    except ValueError:
        raise HTTPException(status_code=401, detail="Token格式无效")
    
    # 解码Token
    payload = decode_auth_token(token)
    
    # 验证用户是否存在
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Token无效")
    
    sql = "SELECT * FROM user WHERE id = %s"
    users = mysql.mysql_output_data(sql, (user_id,))
    
    if not users:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    return {"user": users[0], "payload": payload}

app=FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,  # 改为True以支持认证
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get('/')
async def home():
    return {'message':"home"}

@app.post('/h5/contact/code')
async def contactCode(item:Code):
    item_dict = item.dict()
    print("item_dict:",item_dict)
    code = contact.getCode()
    content="验证码为：%s" % code
    print("content:",content)
    redis.r_set(item_dict['email'], code)
    # contact.postMail(item_dict['email'], content)
    return {"success":True}

#sign
@app.post('/h5/contact/sign')
async def contactLogin(item:Sign):
    item_dict=item.dict()
    print("item:",item_dict)
    # return {"success":True}
    return item_dict

#login
@app.post('/h5/contact/login')
async def contactLogin(item:User):
    item_dict = item.dict()
    username = item_dict['user']
    password = item_dict['passwd']
    
    print("登录请求:", username)
    
    try:
        # 查询用户信息
        sql = "SELECT * FROM user WHERE username = %s"
        users = mysql.mysql_output_data(sql, (username,))
        
        if not users:
            return {"success": False, "message": "用户不存在"}
        
        user = users[0]  # 获取第一个用户
        
        # 验证密码
        if user.get('password') == password:
            # 更新登录时间
            login_time = int(time.time())
            update_sql = "UPDATE user SET login_time = %s WHERE username = %s"
            mysql.mysql_update_data('user', {'login_time': login_time}, 'username', username)
            
            # 生成Token
            token = encode_auth_token(user['id'])
            
            return {
                "success": True,
                "message": "登录成功",
                "token": token,
                "user_id": user['id'],
                "username": user['username']
            }
        else:
            return {"success": False, "message": "密码错误"}
            
    except Exception as e:
        print(f"登录错误: {str(e)}")
        return {"success": False, "message": f"登录失败: {str(e)}"}

#联系人列表
@app.post('/h5/contact/list')
async def contactList(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求联系人列表")
    
    sql = "SELECT * FROM list ORDER BY `initial`"
    data = mysql.mysql_output_data(sql)  
    return {
        "data": data,
        "success": True,
        "user_id": user_info['user']['id']
    }


#联系人详情
@app.post('/h5/contact/info')
async def contactInfo(item:ContactParams, user_info: dict = Depends(verify_token)):
    item_dict = item.dict()
    print(f"用户 {user_info['user']['username']} 请求联系人详情: {item}")
    
    if item_dict.get('id'):
        sql = "SELECT * FROM list WHERE id = %s"
        data = mysql.mysql_output_data(sql, (item_dict['id'],))
        if data:
            return {
                "data": data[0],
                "success": True,
                "user_id": user_info['user']['id']
            }
        else:
            return {"success": False, "message": "联系人不存在"}
    else:
        return {"success": False, "message": "缺少联系人ID"}

# 用户信息接口
@app.get('/h5/contact/userinfo')
async def getUserInfo(user_info: dict = Depends(verify_token)):
    """获取当前登录用户信息"""
    user = user_info['user']
    return {
        "success": True,
        "data": {
            "user_id": user['id'],
            "username": user['username'],
            "email": user.get('email', ''),
            "login_time": user.get('login_time', '')
        }
    }

# Token验证接口
@app.post('/h5/contact/verify')
async def verifyToken(user_info: dict = Depends(verify_token)):
    """验证Token有效性"""
    return {
        "success": True,
        "message": "Token有效",
        "user_id": user_info['user']['id'],
        "exp": user_info['payload'].get('exp')
    }

#baidu OCR
@app.post('/h5/contact/ocr')
async def contactOCR(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求OCR功能")
    
    url = "https://aip.baidubce.com/oauth/2.0/token?client_id=&client_secret=&grant_type=client_credentials"
    payload = ""
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    return {
        "success": True,
        "message": "OCR功能调用成功",
        "user_id": user_info['user']['id']
    }
, v):
            raise ValueError('用户名必须是3-20位的字母、数字或下划线')
        return v
    
    @validator('passwd')
    def validate_passwd(cls, v):
        if len(v) < 6:
            raise ValueError('密码长度不能少于6位')
        return v
    
    @validator('email')
    def validate_email(cls, v):
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

# JWT认证相关函数
def encode_auth_token(user_id: int) -> str:
    """
    生成认证Token
    :param user_id: 用户ID
    :return: JWT Token字符串
    """
    try:
        payload = {
            "user_id": user_id,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
            "iat": datetime.datetime.utcnow(),
            "iss": "telphone-h5-service"
        }
        
        token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGORITHM)
        return token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Token生成失败: {str(e)}")

def decode_auth_token(token: str) -> dict:
    """
    验证Token
    :param token: JWT Token
    :return: 解码后的payload
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效Token")

async def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """
    验证Token依赖函数
    :param authorization: Authorization头
    :return: 用户信息
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="未提供认证Token")
    
    # 提取Bearer Token
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证方案无效")
    except ValueError:
        raise HTTPException(status_code=401, detail="Token格式无效")
    
    # 解码Token
    payload = decode_auth_token(token)
    
    # 验证用户是否存在
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Token无效")
    
    sql = "SELECT * FROM user WHERE id = %s"
    users = mysql.mysql_output_data(sql, (user_id,))
    
    if not users:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    return {"user": users[0], "payload": payload}

app=FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,  # 改为True以支持认证
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get('/')
async def home():
    return {'message':"home"}

@app.post('/h5/contact/code')
async def contactCode(item:Code):
    item_dict = item.dict()
    print("item_dict:",item_dict)
    code = contact.getCode()
    content="验证码为：%s" % code
    print("content:",content)
    redis.r_set(item_dict['email'], code)
    # contact.postMail(item_dict['email'], content)
    return {"success":True}

#sign
@app.post('/h5/contact/sign')
async def contactLogin(item:Sign):
    item_dict=item.dict()
    print("item:",item_dict)
    # return {"success":True}
    return item_dict

#login
@app.post('/h5/contact/login')
async def contactLogin(item:User):
    item_dict = item.dict()
    username = item_dict['user']
    password = item_dict['passwd']
    
    print("登录请求:", username)
    
    try:
        # 查询用户信息
        sql = "SELECT * FROM user WHERE username = %s"
        users = mysql.mysql_output_data(sql, (username,))
        
        if not users:
            return {"success": False, "message": "用户不存在"}
        
        user = users[0]  # 获取第一个用户
        
        # 验证密码
        if user.get('password') == password:
            # 更新登录时间
            login_time = int(time.time())
            update_sql = "UPDATE user SET login_time = %s WHERE username = %s"
            mysql.mysql_update_data('user', {'login_time': login_time}, 'username', username)
            
            # 生成Token
            token = encode_auth_token(user['id'])
            
            return {
                "success": True,
                "message": "登录成功",
                "token": token,
                "user_id": user['id'],
                "username": user['username']
            }
        else:
            return {"success": False, "message": "密码错误"}
            
    except Exception as e:
        print(f"登录错误: {str(e)}")
        return {"success": False, "message": f"登录失败: {str(e)}"}

#联系人列表
@app.post('/h5/contact/list')
async def contactList(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求联系人列表")
    
    sql = "SELECT * FROM list ORDER BY `initial`"
    data = mysql.mysql_output_data(sql)  
    return {
        "data": data,
        "success": True,
        "user_id": user_info['user']['id']
    }


#联系人详情
@app.post('/h5/contact/info')
async def contactInfo(item:ContactParams, user_info: dict = Depends(verify_token)):
    item_dict = item.dict()
    print(f"用户 {user_info['user']['username']} 请求联系人详情: {item}")
    
    if item_dict.get('id'):
        sql = "SELECT * FROM list WHERE id = %s"
        data = mysql.mysql_output_data(sql, (item_dict['id'],))
        if data:
            return {
                "data": data[0],
                "success": True,
                "user_id": user_info['user']['id']
            }
        else:
            return {"success": False, "message": "联系人不存在"}
    else:
        return {"success": False, "message": "缺少联系人ID"}

# 用户信息接口
@app.get('/h5/contact/userinfo')
async def getUserInfo(user_info: dict = Depends(verify_token)):
    """获取当前登录用户信息"""
    user = user_info['user']
    return {
        "success": True,
        "data": {
            "user_id": user['id'],
            "username": user['username'],
            "email": user.get('email', ''),
            "login_time": user.get('login_time', '')
        }
    }

# Token验证接口
@app.post('/h5/contact/verify')
async def verifyToken(user_info: dict = Depends(verify_token)):
    """验证Token有效性"""
    return {
        "success": True,
        "message": "Token有效",
        "user_id": user_info['user']['id'],
        "exp": user_info['payload'].get('exp')
    }

#baidu OCR
@app.post('/h5/contact/ocr')
async def contactOCR(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求OCR功能")
    
    url = "https://aip.baidubce.com/oauth/2.0/token?client_id=&client_secret=&grant_type=client_credentials"
    payload = ""
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    return {
        "success": True,
        "message": "OCR功能调用成功",
        "user_id": user_info['user']['id']
    }
, v):
            raise ValueError('邮箱格式不正确')
        return v

# JWT认证相关函数
def encode_auth_token(user_id: int) -> str:
    """
    生成认证Token
    :param user_id: 用户ID
    :return: JWT Token字符串
    """
    try:
        payload = {
            "user_id": user_id,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
            "iat": datetime.datetime.utcnow(),
            "iss": "telphone-h5-service"
        }
        
        token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGORITHM)
        return token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Token生成失败: {str(e)}")

def decode_auth_token(token: str) -> dict:
    """
    验证Token
    :param token: JWT Token
    :return: 解码后的payload
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效Token")

async def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """
    验证Token依赖函数
    :param authorization: Authorization头
    :return: 用户信息
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="未提供认证Token")
    
    # 提取Bearer Token
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证方案无效")
    except ValueError:
        raise HTTPException(status_code=401, detail="Token格式无效")
    
    # 解码Token
    payload = decode_auth_token(token)
    
    # 验证用户是否存在
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Token无效")
    
    sql = "SELECT * FROM user WHERE id = %s"
    users = mysql.mysql_output_data(sql, (user_id,))
    
    if not users:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    return {"user": users[0], "payload": payload}

app=FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,  # 改为True以支持认证
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get('/')
async def home():
    return {'message':"home"}

@app.post('/h5/contact/code')
async def contactCode(item:Code):
    item_dict = item.dict()
    print("item_dict:",item_dict)
    code = contact.getCode()
    content="验证码为：%s" % code
    print("content:",content)
    redis.r_set(item_dict['email'], code)
    # contact.postMail(item_dict['email'], content)
    return {"success":True}

#sign
@app.post('/h5/contact/sign')
async def contactLogin(item:Sign):
    item_dict=item.dict()
    print("item:",item_dict)
    # return {"success":True}
    return item_dict

#login
@app.post('/h5/contact/login')
async def contactLogin(item:User):
    item_dict = item.dict()
    username = item_dict['user']
    password = item_dict['passwd']
    
    print("登录请求:", username)
    
    try:
        # 查询用户信息
        sql = "SELECT * FROM user WHERE username = %s"
        users = mysql.mysql_output_data(sql, (username,))
        
        if not users:
            return {"success": False, "message": "用户不存在"}
        
        user = users[0]  # 获取第一个用户
        
        # 验证密码
        if user.get('password') == password:
            # 更新登录时间
            login_time = int(time.time())
            update_sql = "UPDATE user SET login_time = %s WHERE username = %s"
            mysql.mysql_update_data('user', {'login_time': login_time}, 'username', username)
            
            # 生成Token
            token = encode_auth_token(user['id'])
            
            return {
                "success": True,
                "message": "登录成功",
                "token": token,
                "user_id": user['id'],
                "username": user['username']
            }
        else:
            return {"success": False, "message": "密码错误"}
            
    except Exception as e:
        print(f"登录错误: {str(e)}")
        return {"success": False, "message": f"登录失败: {str(e)}"}

#联系人列表
@app.post('/h5/contact/list')
async def contactList(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求联系人列表")
    
    sql = "SELECT * FROM list ORDER BY `initial`"
    data = mysql.mysql_output_data(sql)  
    return {
        "data": data,
        "success": True,
        "user_id": user_info['user']['id']
    }


#联系人详情
@app.post('/h5/contact/info')
async def contactInfo(item:ContactParams, user_info: dict = Depends(verify_token)):
    item_dict = item.dict()
    print(f"用户 {user_info['user']['username']} 请求联系人详情: {item}")
    
    if item_dict.get('id'):
        sql = "SELECT * FROM list WHERE id = %s"
        data = mysql.mysql_output_data(sql, (item_dict['id'],))
        if data:
            return {
                "data": data[0],
                "success": True,
                "user_id": user_info['user']['id']
            }
        else:
            return {"success": False, "message": "联系人不存在"}
    else:
        return {"success": False, "message": "缺少联系人ID"}

# 用户信息接口
@app.get('/h5/contact/userinfo')
async def getUserInfo(user_info: dict = Depends(verify_token)):
    """获取当前登录用户信息"""
    user = user_info['user']
    return {
        "success": True,
        "data": {
            "user_id": user['id'],
            "username": user['username'],
            "email": user.get('email', ''),
            "login_time": user.get('login_time', '')
        }
    }

# Token验证接口
@app.post('/h5/contact/verify')
async def verifyToken(user_info: dict = Depends(verify_token)):
    """验证Token有效性"""
    return {
        "success": True,
        "message": "Token有效",
        "user_id": user_info['user']['id'],
        "exp": user_info['payload'].get('exp')
    }

#baidu OCR
@app.post('/h5/contact/ocr')
async def contactOCR(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求OCR功能")
    
    url = "https://aip.baidubce.com/oauth/2.0/token?client_id=&client_secret=&grant_type=client_credentials"
    payload = ""
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    return {
        "success": True,
        "message": "OCR功能调用成功",
        "user_id": user_info['user']['id']
    }
, v):
            raise ValueError('邮箱格式不正确')
        return v

class Sign(BaseModel):
    user:str
    passwd:str
    email:str
    code:Union[str,None]=None
    
    @validator('user')
    def validate_user(cls, v):
        if not re.match(r'^[a-zA-Z0-9_]{3,20}

# JWT认证相关函数
def encode_auth_token(user_id: int) -> str:
    """
    生成认证Token
    :param user_id: 用户ID
    :return: JWT Token字符串
    """
    try:
        payload = {
            "user_id": user_id,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
            "iat": datetime.datetime.utcnow(),
            "iss": "telphone-h5-service"
        }
        
        token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGORITHM)
        return token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Token生成失败: {str(e)}")

def decode_auth_token(token: str) -> dict:
    """
    验证Token
    :param token: JWT Token
    :return: 解码后的payload
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效Token")

async def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """
    验证Token依赖函数
    :param authorization: Authorization头
    :return: 用户信息
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="未提供认证Token")
    
    # 提取Bearer Token
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证方案无效")
    except ValueError:
        raise HTTPException(status_code=401, detail="Token格式无效")
    
    # 解码Token
    payload = decode_auth_token(token)
    
    # 验证用户是否存在
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Token无效")
    
    sql = "SELECT * FROM user WHERE id = %s"
    users = mysql.mysql_output_data(sql, (user_id,))
    
    if not users:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    return {"user": users[0], "payload": payload}

app=FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,  # 改为True以支持认证
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get('/')
async def home():
    return {'message':"home"}

@app.post('/h5/contact/code')
async def contactCode(item:Code):
    item_dict = item.dict()
    print("item_dict:",item_dict)
    code = contact.getCode()
    content="验证码为：%s" % code
    print("content:",content)
    redis.r_set(item_dict['email'], code)
    # contact.postMail(item_dict['email'], content)
    return {"success":True}

#sign
@app.post('/h5/contact/sign')
async def contactLogin(item:Sign):
    item_dict=item.dict()
    print("item:",item_dict)
    # return {"success":True}
    return item_dict

#login
@app.post('/h5/contact/login')
async def contactLogin(item:User):
    item_dict = item.dict()
    username = item_dict['user']
    password = item_dict['passwd']
    
    print("登录请求:", username)
    
    try:
        # 查询用户信息
        sql = "SELECT * FROM user WHERE username = %s"
        users = mysql.mysql_output_data(sql, (username,))
        
        if not users:
            return {"success": False, "message": "用户不存在"}
        
        user = users[0]  # 获取第一个用户
        
        # 验证密码
        if user.get('password') == password:
            # 更新登录时间
            login_time = int(time.time())
            update_sql = "UPDATE user SET login_time = %s WHERE username = %s"
            mysql.mysql_update_data('user', {'login_time': login_time}, 'username', username)
            
            # 生成Token
            token = encode_auth_token(user['id'])
            
            return {
                "success": True,
                "message": "登录成功",
                "token": token,
                "user_id": user['id'],
                "username": user['username']
            }
        else:
            return {"success": False, "message": "密码错误"}
            
    except Exception as e:
        print(f"登录错误: {str(e)}")
        return {"success": False, "message": f"登录失败: {str(e)}"}

#联系人列表
@app.post('/h5/contact/list')
async def contactList(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求联系人列表")
    
    sql = "SELECT * FROM list ORDER BY `initial`"
    data = mysql.mysql_output_data(sql)  
    return {
        "data": data,
        "success": True,
        "user_id": user_info['user']['id']
    }


#联系人详情
@app.post('/h5/contact/info')
async def contactInfo(item:ContactParams, user_info: dict = Depends(verify_token)):
    item_dict = item.dict()
    print(f"用户 {user_info['user']['username']} 请求联系人详情: {item}")
    
    if item_dict.get('id'):
        sql = "SELECT * FROM list WHERE id = %s"
        data = mysql.mysql_output_data(sql, (item_dict['id'],))
        if data:
            return {
                "data": data[0],
                "success": True,
                "user_id": user_info['user']['id']
            }
        else:
            return {"success": False, "message": "联系人不存在"}
    else:
        return {"success": False, "message": "缺少联系人ID"}

# 用户信息接口
@app.get('/h5/contact/userinfo')
async def getUserInfo(user_info: dict = Depends(verify_token)):
    """获取当前登录用户信息"""
    user = user_info['user']
    return {
        "success": True,
        "data": {
            "user_id": user['id'],
            "username": user['username'],
            "email": user.get('email', ''),
            "login_time": user.get('login_time', '')
        }
    }

# Token验证接口
@app.post('/h5/contact/verify')
async def verifyToken(user_info: dict = Depends(verify_token)):
    """验证Token有效性"""
    return {
        "success": True,
        "message": "Token有效",
        "user_id": user_info['user']['id'],
        "exp": user_info['payload'].get('exp')
    }

#baidu OCR
@app.post('/h5/contact/ocr')
async def contactOCR(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求OCR功能")
    
    url = "https://aip.baidubce.com/oauth/2.0/token?client_id=&client_secret=&grant_type=client_credentials"
    payload = ""
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    return {
        "success": True,
        "message": "OCR功能调用成功",
        "user_id": user_info['user']['id']
    }
, v):
            raise ValueError('用户名必须是3-20位的字母、数字或下划线')
        return v
    
    @validator('passwd')
    def validate_passwd(cls, v):
        if len(v) < 6:
            raise ValueError('密码长度不能少于6位')
        return v
    
    @validator('email')
    def validate_email(cls, v):
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

# JWT认证相关函数
def encode_auth_token(user_id: int) -> str:
    """
    生成认证Token
    :param user_id: 用户ID
    :return: JWT Token字符串
    """
    try:
        payload = {
            "user_id": user_id,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
            "iat": datetime.datetime.utcnow(),
            "iss": "telphone-h5-service"
        }
        
        token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGORITHM)
        return token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Token生成失败: {str(e)}")

def decode_auth_token(token: str) -> dict:
    """
    验证Token
    :param token: JWT Token
    :return: 解码后的payload
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效Token")

async def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """
    验证Token依赖函数
    :param authorization: Authorization头
    :return: 用户信息
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="未提供认证Token")
    
    # 提取Bearer Token
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证方案无效")
    except ValueError:
        raise HTTPException(status_code=401, detail="Token格式无效")
    
    # 解码Token
    payload = decode_auth_token(token)
    
    # 验证用户是否存在
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Token无效")
    
    sql = "SELECT * FROM user WHERE id = %s"
    users = mysql.mysql_output_data(sql, (user_id,))
    
    if not users:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    return {"user": users[0], "payload": payload}

app=FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,  # 改为True以支持认证
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get('/')
async def home():
    return {'message':"home"}

@app.post('/h5/contact/code')
async def contactCode(item:Code):
    item_dict = item.dict()
    print("item_dict:",item_dict)
    code = contact.getCode()
    content="验证码为：%s" % code
    print("content:",content)
    redis.r_set(item_dict['email'], code)
    # contact.postMail(item_dict['email'], content)
    return {"success":True}

#sign
@app.post('/h5/contact/sign')
async def contactLogin(item:Sign):
    item_dict=item.dict()
    print("item:",item_dict)
    # return {"success":True}
    return item_dict

#login
@app.post('/h5/contact/login')
async def contactLogin(item:User):
    item_dict = item.dict()
    username = item_dict['user']
    password = item_dict['passwd']
    
    print("登录请求:", username)
    
    try:
        # 查询用户信息
        sql = "SELECT * FROM user WHERE username = %s"
        users = mysql.mysql_output_data(sql, (username,))
        
        if not users:
            return {"success": False, "message": "用户不存在"}
        
        user = users[0]  # 获取第一个用户
        
        # 验证密码
        if user.get('password') == password:
            # 更新登录时间
            login_time = int(time.time())
            update_sql = "UPDATE user SET login_time = %s WHERE username = %s"
            mysql.mysql_update_data('user', {'login_time': login_time}, 'username', username)
            
            # 生成Token
            token = encode_auth_token(user['id'])
            
            return {
                "success": True,
                "message": "登录成功",
                "token": token,
                "user_id": user['id'],
                "username": user['username']
            }
        else:
            return {"success": False, "message": "密码错误"}
            
    except Exception as e:
        print(f"登录错误: {str(e)}")
        return {"success": False, "message": f"登录失败: {str(e)}"}

#联系人列表
@app.post('/h5/contact/list')
async def contactList(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求联系人列表")
    
    sql = "SELECT * FROM list ORDER BY `initial`"
    data = mysql.mysql_output_data(sql)  
    return {
        "data": data,
        "success": True,
        "user_id": user_info['user']['id']
    }


#联系人详情
@app.post('/h5/contact/info')
async def contactInfo(item:ContactParams, user_info: dict = Depends(verify_token)):
    item_dict = item.dict()
    print(f"用户 {user_info['user']['username']} 请求联系人详情: {item}")
    
    if item_dict.get('id'):
        sql = "SELECT * FROM list WHERE id = %s"
        data = mysql.mysql_output_data(sql, (item_dict['id'],))
        if data:
            return {
                "data": data[0],
                "success": True,
                "user_id": user_info['user']['id']
            }
        else:
            return {"success": False, "message": "联系人不存在"}
    else:
        return {"success": False, "message": "缺少联系人ID"}

# 用户信息接口
@app.get('/h5/contact/userinfo')
async def getUserInfo(user_info: dict = Depends(verify_token)):
    """获取当前登录用户信息"""
    user = user_info['user']
    return {
        "success": True,
        "data": {
            "user_id": user['id'],
            "username": user['username'],
            "email": user.get('email', ''),
            "login_time": user.get('login_time', '')
        }
    }

# Token验证接口
@app.post('/h5/contact/verify')
async def verifyToken(user_info: dict = Depends(verify_token)):
    """验证Token有效性"""
    return {
        "success": True,
        "message": "Token有效",
        "user_id": user_info['user']['id'],
        "exp": user_info['payload'].get('exp')
    }

#baidu OCR
@app.post('/h5/contact/ocr')
async def contactOCR(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求OCR功能")
    
    url = "https://aip.baidubce.com/oauth/2.0/token?client_id=&client_secret=&grant_type=client_credentials"
    payload = ""
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    return {
        "success": True,
        "message": "OCR功能调用成功",
        "user_id": user_info['user']['id']
    }
, v):
            raise ValueError('邮箱格式不正确')
        return v

# JWT认证相关函数
def encode_auth_token(user_id: int) -> str:
    """
    生成认证Token
    :param user_id: 用户ID
    :return: JWT Token字符串
    """
    try:
        payload = {
            "user_id": user_id,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
            "iat": datetime.datetime.utcnow(),
            "iss": "telphone-h5-service"
        }
        
        token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGORITHM)
        return token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Token生成失败: {str(e)}")

def decode_auth_token(token: str) -> dict:
    """
    验证Token
    :param token: JWT Token
    :return: 解码后的payload
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效Token")

async def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """
    验证Token依赖函数
    :param authorization: Authorization头
    :return: 用户信息
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="未提供认证Token")
    
    # 提取Bearer Token
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证方案无效")
    except ValueError:
        raise HTTPException(status_code=401, detail="Token格式无效")
    
    # 解码Token
    payload = decode_auth_token(token)
    
    # 验证用户是否存在
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Token无效")
    
    sql = "SELECT * FROM user WHERE id = %s"
    users = mysql.mysql_output_data(sql, (user_id,))
    
    if not users:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    return {"user": users[0], "payload": payload}

app=FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,  # 改为True以支持认证
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get('/')
async def home():
    return {'message':"home"}

@app.post('/h5/contact/code')
async def contactCode(item:Code):
    item_dict = item.dict()
    print("item_dict:",item_dict)
    code = contact.getCode()
    content="验证码为：%s" % code
    print("content:",content)
    redis.r_set(item_dict['email'], code)
    # contact.postMail(item_dict['email'], content)
    return {"success":True}

#sign
@app.post('/h5/contact/sign')
async def contactLogin(item:Sign):
    item_dict=item.dict()
    print("item:",item_dict)
    # return {"success":True}
    return item_dict

#login
@app.post('/h5/contact/login')
async def contactLogin(item:User):
    item_dict = item.dict()
    username = item_dict['user']
    password = item_dict['passwd']
    
    print("登录请求:", username)
    
    try:
        # 查询用户信息
        sql = "SELECT * FROM user WHERE username = %s"
        users = mysql.mysql_output_data(sql, (username,))
        
        if not users:
            return {"success": False, "message": "用户不存在"}
        
        user = users[0]  # 获取第一个用户
        
        # 验证密码
        if user.get('password') == password:
            # 更新登录时间
            login_time = int(time.time())
            update_sql = "UPDATE user SET login_time = %s WHERE username = %s"
            mysql.mysql_update_data('user', {'login_time': login_time}, 'username', username)
            
            # 生成Token
            token = encode_auth_token(user['id'])
            
            return {
                "success": True,
                "message": "登录成功",
                "token": token,
                "user_id": user['id'],
                "username": user['username']
            }
        else:
            return {"success": False, "message": "密码错误"}
            
    except Exception as e:
        print(f"登录错误: {str(e)}")
        return {"success": False, "message": f"登录失败: {str(e)}"}

#联系人列表
@app.post('/h5/contact/list')
async def contactList(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求联系人列表")
    
    sql = "SELECT * FROM list ORDER BY `initial`"
    data = mysql.mysql_output_data(sql)  
    return {
        "data": data,
        "success": True,
        "user_id": user_info['user']['id']
    }


#联系人详情
@app.post('/h5/contact/info')
async def contactInfo(item:ContactParams, user_info: dict = Depends(verify_token)):
    item_dict = item.dict()
    print(f"用户 {user_info['user']['username']} 请求联系人详情: {item}")
    
    if item_dict.get('id'):
        sql = "SELECT * FROM list WHERE id = %s"
        data = mysql.mysql_output_data(sql, (item_dict['id'],))
        if data:
            return {
                "data": data[0],
                "success": True,
                "user_id": user_info['user']['id']
            }
        else:
            return {"success": False, "message": "联系人不存在"}
    else:
        return {"success": False, "message": "缺少联系人ID"}

# 用户信息接口
@app.get('/h5/contact/userinfo')
async def getUserInfo(user_info: dict = Depends(verify_token)):
    """获取当前登录用户信息"""
    user = user_info['user']
    return {
        "success": True,
        "data": {
            "user_id": user['id'],
            "username": user['username'],
            "email": user.get('email', ''),
            "login_time": user.get('login_time', '')
        }
    }

# Token验证接口
@app.post('/h5/contact/verify')
async def verifyToken(user_info: dict = Depends(verify_token)):
    """验证Token有效性"""
    return {
        "success": True,
        "message": "Token有效",
        "user_id": user_info['user']['id'],
        "exp": user_info['payload'].get('exp')
    }

#baidu OCR
@app.post('/h5/contact/ocr')
async def contactOCR(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求OCR功能")
    
    url = "https://aip.baidubce.com/oauth/2.0/token?client_id=&client_secret=&grant_type=client_credentials"
    payload = ""
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    return {
        "success": True,
        "message": "OCR功能调用成功",
        "user_id": user_info['user']['id']
    }
, v):
            raise ValueError('手机号格式不正确')
        return v

class ContactParams(BaseModel):
    id:Union[int,None]=None

class User(BaseModel):
    user:str
    passwd:str

class Code(BaseModel):
    email:str

class Sign(BaseModel):
    user:str
    passwd:str
    email:str
    code:Union[str,None]=None
    
    @validator('user')
    def validate_user(cls, v):
        if not re.match(r'^[a-zA-Z0-9_]{3,20}

# JWT认证相关函数
def encode_auth_token(user_id: int) -> str:
    """
    生成认证Token
    :param user_id: 用户ID
    :return: JWT Token字符串
    """
    try:
        payload = {
            "user_id": user_id,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
            "iat": datetime.datetime.utcnow(),
            "iss": "telphone-h5-service"
        }
        
        token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGORITHM)
        return token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Token生成失败: {str(e)}")

def decode_auth_token(token: str) -> dict:
    """
    验证Token
    :param token: JWT Token
    :return: 解码后的payload
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效Token")

async def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """
    验证Token依赖函数
    :param authorization: Authorization头
    :return: 用户信息
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="未提供认证Token")
    
    # 提取Bearer Token
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证方案无效")
    except ValueError:
        raise HTTPException(status_code=401, detail="Token格式无效")
    
    # 解码Token
    payload = decode_auth_token(token)
    
    # 验证用户是否存在
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Token无效")
    
    sql = "SELECT * FROM user WHERE id = %s"
    users = mysql.mysql_output_data(sql, (user_id,))
    
    if not users:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    return {"user": users[0], "payload": payload}

app=FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,  # 改为True以支持认证
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get('/')
async def home():
    return {'message':"home"}

@app.post('/h5/contact/code')
async def contactCode(item:Code):
    item_dict = item.dict()
    print("item_dict:",item_dict)
    code = contact.getCode()
    content="验证码为：%s" % code
    print("content:",content)
    redis.r_set(item_dict['email'], code)
    # contact.postMail(item_dict['email'], content)
    return {"success":True}

#sign
@app.post('/h5/contact/sign')
async def contactLogin(item:Sign):
    item_dict=item.dict()
    print("item:",item_dict)
    # return {"success":True}
    return item_dict

#login
@app.post('/h5/contact/login')
async def contactLogin(item:User):
    item_dict = item.dict()
    username = item_dict['user']
    password = item_dict['passwd']
    
    print("登录请求:", username)
    
    try:
        # 查询用户信息
        sql = "SELECT * FROM user WHERE username = %s"
        users = mysql.mysql_output_data(sql, (username,))
        
        if not users:
            return {"success": False, "message": "用户不存在"}
        
        user = users[0]  # 获取第一个用户
        
        # 验证密码
        if user.get('password') == password:
            # 更新登录时间
            login_time = int(time.time())
            update_sql = "UPDATE user SET login_time = %s WHERE username = %s"
            mysql.mysql_update_data('user', {'login_time': login_time}, 'username', username)
            
            # 生成Token
            token = encode_auth_token(user['id'])
            
            return {
                "success": True,
                "message": "登录成功",
                "token": token,
                "user_id": user['id'],
                "username": user['username']
            }
        else:
            return {"success": False, "message": "密码错误"}
            
    except Exception as e:
        print(f"登录错误: {str(e)}")
        return {"success": False, "message": f"登录失败: {str(e)}"}

#联系人列表
@app.post('/h5/contact/list')
async def contactList(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求联系人列表")
    
    sql = "SELECT * FROM list ORDER BY `initial`"
    data = mysql.mysql_output_data(sql)  
    return {
        "data": data,
        "success": True,
        "user_id": user_info['user']['id']
    }


#联系人详情
@app.post('/h5/contact/info')
async def contactInfo(item:ContactParams, user_info: dict = Depends(verify_token)):
    item_dict = item.dict()
    print(f"用户 {user_info['user']['username']} 请求联系人详情: {item}")
    
    if item_dict.get('id'):
        sql = "SELECT * FROM list WHERE id = %s"
        data = mysql.mysql_output_data(sql, (item_dict['id'],))
        if data:
            return {
                "data": data[0],
                "success": True,
                "user_id": user_info['user']['id']
            }
        else:
            return {"success": False, "message": "联系人不存在"}
    else:
        return {"success": False, "message": "缺少联系人ID"}

# 用户信息接口
@app.get('/h5/contact/userinfo')
async def getUserInfo(user_info: dict = Depends(verify_token)):
    """获取当前登录用户信息"""
    user = user_info['user']
    return {
        "success": True,
        "data": {
            "user_id": user['id'],
            "username": user['username'],
            "email": user.get('email', ''),
            "login_time": user.get('login_time', '')
        }
    }

# Token验证接口
@app.post('/h5/contact/verify')
async def verifyToken(user_info: dict = Depends(verify_token)):
    """验证Token有效性"""
    return {
        "success": True,
        "message": "Token有效",
        "user_id": user_info['user']['id'],
        "exp": user_info['payload'].get('exp')
    }

#baidu OCR
@app.post('/h5/contact/ocr')
async def contactOCR(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求OCR功能")
    
    url = "https://aip.baidubce.com/oauth/2.0/token?client_id=&client_secret=&grant_type=client_credentials"
    payload = ""
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    return {
        "success": True,
        "message": "OCR功能调用成功",
        "user_id": user_info['user']['id']
    }
, v):
            raise ValueError('用户名必须是3-20位的字母、数字或下划线')
        return v
    
    @validator('passwd')
    def validate_passwd(cls, v):
        if len(v) < 6:
            raise ValueError('密码长度不能少于6位')
        return v
    
    @validator('email')
    def validate_email(cls, v):
        if not re.match(r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}

# JWT认证相关函数
def encode_auth_token(user_id: int) -> str:
    """
    生成认证Token
    :param user_id: 用户ID
    :return: JWT Token字符串
    """
    try:
        payload = {
            "user_id": user_id,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
            "iat": datetime.datetime.utcnow(),
            "iss": "telphone-h5-service"
        }
        
        token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGORITHM)
        return token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Token生成失败: {str(e)}")

def decode_auth_token(token: str) -> dict:
    """
    验证Token
    :param token: JWT Token
    :return: 解码后的payload
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效Token")

async def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """
    验证Token依赖函数
    :param authorization: Authorization头
    :return: 用户信息
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="未提供认证Token")
    
    # 提取Bearer Token
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证方案无效")
    except ValueError:
        raise HTTPException(status_code=401, detail="Token格式无效")
    
    # 解码Token
    payload = decode_auth_token(token)
    
    # 验证用户是否存在
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Token无效")
    
    sql = "SELECT * FROM user WHERE id = %s"
    users = mysql.mysql_output_data(sql, (user_id,))
    
    if not users:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    return {"user": users[0], "payload": payload}

app=FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,  # 改为True以支持认证
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get('/')
async def home():
    return {'message':"home"}

@app.post('/h5/contact/code')
async def contactCode(item:Code):
    item_dict = item.dict()
    print("item_dict:",item_dict)
    code = contact.getCode()
    content="验证码为：%s" % code
    print("content:",content)
    redis.r_set(item_dict['email'], code)
    # contact.postMail(item_dict['email'], content)
    return {"success":True}

#sign
@app.post('/h5/contact/sign')
async def contactLogin(item:Sign):
    item_dict=item.dict()
    print("item:",item_dict)
    # return {"success":True}
    return item_dict

#login
@app.post('/h5/contact/login')
async def contactLogin(item:User):
    item_dict = item.dict()
    username = item_dict['user']
    password = item_dict['passwd']
    
    print("登录请求:", username)
    
    try:
        # 查询用户信息
        sql = "SELECT * FROM user WHERE username = %s"
        users = mysql.mysql_output_data(sql, (username,))
        
        if not users:
            return {"success": False, "message": "用户不存在"}
        
        user = users[0]  # 获取第一个用户
        
        # 验证密码
        if user.get('password') == password:
            # 更新登录时间
            login_time = int(time.time())
            update_sql = "UPDATE user SET login_time = %s WHERE username = %s"
            mysql.mysql_update_data('user', {'login_time': login_time}, 'username', username)
            
            # 生成Token
            token = encode_auth_token(user['id'])
            
            return {
                "success": True,
                "message": "登录成功",
                "token": token,
                "user_id": user['id'],
                "username": user['username']
            }
        else:
            return {"success": False, "message": "密码错误"}
            
    except Exception as e:
        print(f"登录错误: {str(e)}")
        return {"success": False, "message": f"登录失败: {str(e)}"}

#联系人列表
@app.post('/h5/contact/list')
async def contactList(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求联系人列表")
    
    sql = "SELECT * FROM list ORDER BY `initial`"
    data = mysql.mysql_output_data(sql)  
    return {
        "data": data,
        "success": True,
        "user_id": user_info['user']['id']
    }


#联系人详情
@app.post('/h5/contact/info')
async def contactInfo(item:ContactParams, user_info: dict = Depends(verify_token)):
    item_dict = item.dict()
    print(f"用户 {user_info['user']['username']} 请求联系人详情: {item}")
    
    if item_dict.get('id'):
        sql = "SELECT * FROM list WHERE id = %s"
        data = mysql.mysql_output_data(sql, (item_dict['id'],))
        if data:
            return {
                "data": data[0],
                "success": True,
                "user_id": user_info['user']['id']
            }
        else:
            return {"success": False, "message": "联系人不存在"}
    else:
        return {"success": False, "message": "缺少联系人ID"}

# 用户信息接口
@app.get('/h5/contact/userinfo')
async def getUserInfo(user_info: dict = Depends(verify_token)):
    """获取当前登录用户信息"""
    user = user_info['user']
    return {
        "success": True,
        "data": {
            "user_id": user['id'],
            "username": user['username'],
            "email": user.get('email', ''),
            "login_time": user.get('login_time', '')
        }
    }

# Token验证接口
@app.post('/h5/contact/verify')
async def verifyToken(user_info: dict = Depends(verify_token)):
    """验证Token有效性"""
    return {
        "success": True,
        "message": "Token有效",
        "user_id": user_info['user']['id'],
        "exp": user_info['payload'].get('exp')
    }

#baidu OCR
@app.post('/h5/contact/ocr')
async def contactOCR(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求OCR功能")
    
    url = "https://aip.baidubce.com/oauth/2.0/token?client_id=&client_secret=&grant_type=client_credentials"
    payload = ""
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    return {
        "success": True,
        "message": "OCR功能调用成功",
        "user_id": user_info['user']['id']
    }
, v):
            raise ValueError('邮箱格式不正确')
        return v

# JWT认证相关函数
def encode_auth_token(user_id: int) -> str:
    """
    生成认证Token
    :param user_id: 用户ID
    :return: JWT Token字符串
    """
    try:
        payload = {
            "user_id": user_id,
            "exp": datetime.datetime.utcnow() + datetime.timedelta(minutes=JWT_EXPIRE_MINUTES),
            "iat": datetime.datetime.utcnow(),
            "iss": "telphone-h5-service"
        }
        
        token = jwt.encode(payload, SECRET_KEY, algorithm=JWT_ALGORITHM)
        return token
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Token生成失败: {str(e)}")

def decode_auth_token(token: str) -> dict:
    """
    验证Token
    :param token: JWT Token
    :return: 解码后的payload
    """
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token已过期")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="无效Token")

async def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """
    验证Token依赖函数
    :param authorization: Authorization头
    :return: 用户信息
    """
    if not authorization:
        raise HTTPException(status_code=401, detail="未提供认证Token")
    
    # 提取Bearer Token
    try:
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="认证方案无效")
    except ValueError:
        raise HTTPException(status_code=401, detail="Token格式无效")
    
    # 解码Token
    payload = decode_auth_token(token)
    
    # 验证用户是否存在
    user_id = payload.get("user_id")
    if not user_id:
        raise HTTPException(status_code=401, detail="Token无效")
    
    sql = "SELECT * FROM user WHERE id = %s"
    users = mysql.mysql_output_data(sql, (user_id,))
    
    if not users:
        raise HTTPException(status_code=401, detail="用户不存在")
    
    return {"user": users[0], "payload": payload}

app=FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,  # 改为True以支持认证
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get('/')
async def home():
    return {'message':"home"}

@app.post('/h5/contact/code')
async def contactCode(item:Code):
    item_dict = item.dict()
    print("item_dict:",item_dict)
    code = contact.getCode()
    content="验证码为：%s" % code
    print("content:",content)
    redis.r_set(item_dict['email'], code)
    # contact.postMail(item_dict['email'], content)
    return {"success":True}

#sign
@app.post('/h5/contact/sign')
async def contactLogin(item:Sign):
    item_dict=item.dict()
    print("item:",item_dict)
    # return {"success":True}
    return item_dict

#login
@app.post('/h5/contact/login')
async def contactLogin(item:User):
    item_dict = item.dict()
    username = item_dict['user']
    password = item_dict['passwd']
    
    print("登录请求:", username)
    
    try:
        # 查询用户信息
        sql = "SELECT * FROM user WHERE username = %s"
        users = mysql.mysql_output_data(sql, (username,))
        
        if not users:
            return {"success": False, "message": "用户不存在"}
        
        user = users[0]  # 获取第一个用户
        
        # 验证密码
        if user.get('password') == password:
            # 更新登录时间
            login_time = int(time.time())
            update_sql = "UPDATE user SET login_time = %s WHERE username = %s"
            mysql.mysql_update_data('user', {'login_time': login_time}, 'username', username)
            
            # 生成Token
            token = encode_auth_token(user['id'])
            
            return {
                "success": True,
                "message": "登录成功",
                "token": token,
                "user_id": user['id'],
                "username": user['username']
            }
        else:
            return {"success": False, "message": "密码错误"}
            
    except Exception as e:
        print(f"登录错误: {str(e)}")
        return {"success": False, "message": f"登录失败: {str(e)}"}

#联系人列表
@app.post('/h5/contact/list')
async def contactList(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求联系人列表")
    
    sql = "SELECT * FROM list ORDER BY `initial`"
    data = mysql.mysql_output_data(sql)  
    return {
        "data": data,
        "success": True,
        "user_id": user_info['user']['id']
    }


#联系人详情
@app.post('/h5/contact/info')
async def contactInfo(item:ContactParams, user_info: dict = Depends(verify_token)):
    item_dict = item.dict()
    print(f"用户 {user_info['user']['username']} 请求联系人详情: {item}")
    
    if item_dict.get('id'):
        sql = "SELECT * FROM list WHERE id = %s"
        data = mysql.mysql_output_data(sql, (item_dict['id'],))
        if data:
            return {
                "data": data[0],
                "success": True,
                "user_id": user_info['user']['id']
            }
        else:
            return {"success": False, "message": "联系人不存在"}
    else:
        return {"success": False, "message": "缺少联系人ID"}

# 用户信息接口
@app.get('/h5/contact/userinfo')
async def getUserInfo(user_info: dict = Depends(verify_token)):
    """获取当前登录用户信息"""
    user = user_info['user']
    return {
        "success": True,
        "data": {
            "user_id": user['id'],
            "username": user['username'],
            "email": user.get('email', ''),
            "login_time": user.get('login_time', '')
        }
    }

# Token验证接口
@app.post('/h5/contact/verify')
async def verifyToken(user_info: dict = Depends(verify_token)):
    """验证Token有效性"""
    return {
        "success": True,
        "message": "Token有效",
        "user_id": user_info['user']['id'],
        "exp": user_info['payload'].get('exp')
    }

#baidu OCR
@app.post('/h5/contact/ocr')
async def contactOCR(item:ContactParams, user_info: dict = Depends(verify_token)):
    print(f"用户 {user_info['user']['username']} 请求OCR功能")
    
    url = "https://aip.baidubce.com/oauth/2.0/token?client_id=&client_secret=&grant_type=client_credentials"
    payload = ""
    headers = {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
    }
    response = requests.request("POST", url, headers=headers, data=payload)
    print(response.text)
    return {
        "success": True,
        "message": "OCR功能调用成功",
        "user_id": user_info['user']['id']
    }
